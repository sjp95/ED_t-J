#ifndef HOPPING_HPP_INCLUDED
#define HOPPING_HPP_INCLUDED
//#include "input.hpp"
#include <Eigen/Dense>
#include "../input/input.hpp"
#include "../input/input.hpp"
#include "Hamiltonian.hpp"
#include <complex>
using namespace std;
using namespace Eigen;

//===================================================================================================//
                                    //==== Electronic Hoping ====//
//===================================================================================================//



//================================================================//
                            //== Up ==//
//================================================================//
void input:: hoping_up( int i, int nn)
{   
    //===========================//
    int n = i;
    int x= nCr(N,nup);
    int vup= int(i%x);
    int vdown=int(i/x);
    //===========================//

    //===========================//
    pob_up_n(vup);
    pob_down_n(vdown);
    VectorXi ai=upi;
    //===========================//
    
    //===========================//
    for(int k1=0; k1<N;k1++)
    for(int k2=k1+1; k2<N; k2++)
    {
        //======================//
        int kk=k2%N;
        //cout<< nn <<"    "<<downi(k1)+downi(k2)<<endl;
        //======================//
        if(kk>k1 && downi(k1)+downi(k2)<1) //elimination of double occupation
        {
            //====================================================//
                  //====Sign of the hopping & prefactor====//
            //====================================================//
            double pre=1.0;
            int pre0=1;
            for (int aa = k1; aa < kk; aa++)
            {
                pre*=double(pow(-1,ai(aa))*ai(kk)*(1-ai(k1)));
                pre0*=int(pow(-1,ai(aa))*ai(kk)*(1-ai(k1)));
            }
            //====================================================//
            //====================================================//
            //cout<< nn <<"    "<<endl;
            if(abs(pre0)>0)
            {
                //======================//
                //======================//
                int id1 =0, id2=0;
                //======================//
                if (upi(k1)==1)
                {
                    upi(k1)-=1;
                }
                else
                {
                    upi(k1)+=1;
                    id1++;
                }   
                //=====================//           
                if (upi(kk)==1)
                {
                    upi(kk)-=1;
                    id2++;
                }
                else
                {
                    upi(kk)+=1;
                }
                //======================//
                //======================//
            
                //==================================================================//
                int q=int(vdown*x+pob_up_v()); // Reconstruction of the new basis
                q=find(q); // finding the new basis location
                //==================================================================//
                //cout<< nn <<"    "<<q<<"    "<<downi(k1)+downi(k2)<<endl;
                //===========================================//
                        //====defining the hopping====//
                //===========================================//
                if (nn!=q && id1*id2!=0 && q!=-1)
                {
                    H0(q,nn)+=complex<double>(tt(k1,kk)*pre);
                    H0(nn,q)=conj(H0(q,nn));
                }
                //===========================================//
                //===========================================//

                upi=ai;
            }
        }
    }

    //cout<< H << endl;
}
//===========================================================================================//
//===========================================================================================//



//================================================================//
                            //== Douw ==//
//================================================================//
void input:: hoping_down( int i,int nn)
{
    //===========================//
    int n = i;
    int x= nCr(N,nup);
    int vup= int(i%x);
    int vdown=int(i/x);
    
    //===========================//
    //===========================//
    pob_up_n(vup);
    pob_down_n(vdown);
    VectorXi ai=downi;
    //===========================//

    for(int k1=0; k1<N;k1++)
    for(int k2=k1+1; k2<N; k2++)
    {
        //======================//
        int kk=k2%N;
        //======================//
        if(kk>k1 && upi(k1)+upi(kk)<1) //elimination of double occupation
        {
            //====================================================//
                  //====Sign of the hopping & prefactor====//
            //====================================================//
            double pre=1.0;
            double pre1=double(pow(-1.0,2*nup));
            int pre0=1;
            for (int aa = k1; aa < kk; aa++)
            {
                pre*=double(pow(-1,ai(aa))*ai(kk)*(1-ai(k1)));
                pre0*=int(pow(-1,ai(aa))*ai(kk)*(1-ai(k1)));
            }
            //====================================================//
            //====================================================//

            if(abs(pre0)>0)
            {  
                //======================// 
                //======================//
                int id1 =0, id2=0;
                //======================//
                if (downi(k1)==1)
                {
                    downi(k1)-=1;
                }
                else
                {
                    downi(k1)+=1;
                    id1++;
                }   
                //=====================//           
                if (downi(kk)==1)
                {
                    downi(kk)-=1;
                    id2++;
                }
                else
                {
                    downi(kk)+=1;
                }
                //======================//
                //======================//

                //=================================================================//
                int q=int(pob_down_v()*x+vup); // Reconstruction of the new basis
                q=find(q);   // finding the new basis location
                //=================================================================//
                // cout<< nn <<"    "<<q<<endl;
                
                //=============================================//
                         //====defining the hopping====//
                //=============================================//   
                if (nn!=q && id1*id2!=0 && q!=-1)
                {
                    H0(q,nn)+=complex<double>(tt(k1,kk)*pre*pre1);
                    H0(nn,q)=conj(H0(q,nn));
                }
                //==============================================//
                //==============================================//   
                downi=ai;
            }
       }
    }
}
//===========================================================================================//
//===========================================================================================//








//===================================================================================================//
                                      //==== Spin Hoping ====//
//===================================================================================================//
void input:: spin_hoping( int i,int nn)
{
    //===========================//
    int n = i;
    int x= nCr(N,nup);
    int vup= int(i%x);
    int vdown=int(i/x);
    //===========================//
    //===========================//
    pob_up_n(vup);
    pob_down_n(vdown);
    VectorXi aupi=upi;
    VectorXi adowni=downi;
    //===========================//

    for(int k1=0; k1<N;k1++)
    for(int k2=k1+1; k2<N; k2++)
    {
        //======================//
        int kk=k2%N;
        //======================//
        if(kk>k1)
        {
            //====================================================//
                  //====Sign of the hopping & prefactor====//
            //====================================================//
            double pre=1.0;
            int pre0=1;
            for (int aa = k1; aa < kk; aa++)
            {
                pre0*=abs(upi(k1)*downi(kk));//upi(kk)*downi(k1)+
            }
            //====================================================//
            //====================================================//

            if(abs(pre0)>0)
            {   
                //======================//
                //======================//
                upi(kk)=1-upi(kk);
                upi(k1)=1-upi(k1);

                downi(kk)=1-downi(kk);
                downi(k1)=1-downi(k1);
                //======================//
                //======================//

                //=================================================================//
                int q=int(pob_down_v()*x+pob_up_v()); // Reconstruction of the new basis
                q=find(q);   // finding the new basis location
                //=================================================================//
                //cout<< nn <<"    "<<q<<endl;
                //=============================================//
                         //====defining the hopping====//
                //=============================================//   
                if (nn!=q && q!=-1)
                {
                    H0(q,nn)+=complex<double>(JJ(k1,kk)*0.5);
                    H0(nn,q)=conj(H0(q,nn));
                }
                //==============================================//
                //==============================================//   
                upi=aupi;
                downi=adowni;
            }
       }
    }
}

//===================================================================================================//
//===================================================================================================//

#endif
